



      Test suite for the Core Language of Standard ML




                  Michael Vium, C 908944

                            and

                  Sten Schmidt, C 908841


              Department of Computer Science
              Technical University of Denmark

























                     September 1, 1994

Contents





     Acknowledgement                                    1

1.0  Introduction                                       2

2.0  What is tested                                     3

3.0  Approach                                           4

3.1  Testing systematically                             4

3.2  Naming files systematically                        4

3.3  Test suite programs                                5

3.4  Testing rule 17                                    6

3.4.1     Test of the valbinding                        7

3.4.2     Test of Closure of the variable environment VE7

4.0  Using the test suite                              12

5.0  Conclusion                                        13

     Bibliography                                      15

A    Appendix: Which rules are used in which files     16

B    Appendix: Test results from four SML implementations22

Acknowledgement





We would like to thank Peter Sestoft at the Department of Computer
Science, Technical University of Denmark for giving us the
opportunity to work on this project. Also, we would like to thank
him for his assistance in the development of this test suite.
1.0 Introduction





This document describes the development of a test suite that can be
used to test Standard ML implementations. A precise and formal
definition of Standard ML is given in The Definition of Standard
ML written by Milner, Tofte, and Harper available from MIT Press.
The idea with this project was systematically to develop a test suite
based on the definitions present in the Definition. The definition of
the Standard ML programming language is different from the
definitions of most other programming languages þ it mathematically
describes not only the grammar but also the meaning of the
language. This is why it seemed reasonable to try to construct a
test suite based on the definitions available, rule by rule. Because
of the time limitations imposed on the project, this test suite is
limited to testing the static semantics for the Core Language of
Standard ML. The dynamic semantics for the Core Language and the
Module Language is not covered by this work.

The test suite is formed by a collection of small Standard ML
programs. Each program is constructed to test a rule or a part of a
rule, e.g. a side condition. Also each program is accompanied by a
description of how the compiler is expected to react to it. For
example, the program might fail because of a type error. On the
other hand, the program might succeed in which case its expected
behaviour must be documented.

An exhaustive test is impossible, so care is needed in selecting
cases that are most likely to reveal errors. Some program
constructions are more complicated than others, and in general more
complicated constructions are somewhat more likely to fool a compiler
than simple ones. Nevertheless, the use of this test suite on four
different Standard ML implementations showed us, that even simple
illegal constructs were accepted by some implementations (for
example, two implementations accepted free imperative type variables
at top level).

Section 2 of this document describes exactly which parts of the
Definition are tested by this test suite and which are not. Section 3
describes the approach used in the development. It contains
information regarding testing systematically, naming files
systematically and the test suite programs in general. Also the
testing of rule 17 is outlined as an example of how rules are tested
systematically. Section 4 describes how to use the test suite. Finally,
section 5 is dedicated to the conclusion. Note, that it is not the
intention with this document to describe the development of each
program in this test suite in detail. Neither does it try to explain
definitions nor rules in the Definition. Anyone interested in the
definitions of Standard ML is advised to take a look at the
Definition or [2].2.0 What is tested





As stated in the introduction this test suite is limited to testing the
static semantics for the Core Language of Standard ML. The dynamic
semantics for the Core Language and the Module Language are not
covered by this work.


This test suite tests

þ    rule 100 and the static semantics for the Core Language (the
     rules from 1 to 52, rule 23 excluded) [chapter 4].

þ    the syntactic restrictions [page 9].

þ    the derived forms [page 67-68].

þ    the first point in the further restrictions [page 30].


This test suite does not test

þ    the Module Language.

þ    the dynamic semantics for the Core Language [chapter 6]

þ    the initial static basis [Appendix C].

þ    the initial dynamic basis [Appendix D] thoroughly.

þ    the grammar of the Core Language [page 8-9] and [Appendix
     B] systematically or thoroughly.

þ    whether the compiler warns regarding match exhaustiveness
     and redundant patterns as demanded in the second point in
     the further restrictions [page 30].

þ    the scoping of explicit type variables in valbindings
     completely (the test programs R017A-AC.ML and R017K-FL.ML
     may however indicate whether the compiler treats the scoping
     correctly).

3.0 Approach





3.1 Testing systematically

The rules in the Definition are tested one by one and the test
programs are kept as simple as possible. This makes it easier to
ensure that the rules are tested in all possible instances. It also
minimizes the chance of problems in one declaration affecting on the
testing of another.

þ    for each rule all the side conditions are tested separately in
     different test programs.

þ    for each side condition there is a program testing that the
     compiler will fail to elaborate when the side condition does not
     hold.

þ    all instances where a side condition does not hold are tested
     separately.

þ    the test programs in the present test suite are generally kept
     very simple except for the test programs for the more
     essential rules in ML.

For each rule there is also one or more programs that test the rule
in general. These are the programs that requires intuition to
construct. The better knowledge of SML implementations and
problems herein, the better test programs one can conceive. They
should be designed so they are most likely to fool a compiler,
although they must remain correct according to the Definition.

Naturally, the biggest problem testing compilers systematically is
that not all side conditions can be tested that easily. For instance,
some of the side conditions make demands on how the compiler
should react internally. This can not be tested directly in a
program. However, if the compiler does not comply with these
conditions it could have unpredictable consequences in the
elaboration of the following declarations. Normally, if the compiler
treats complicated examples correctly, chances are that it will treat
all programs correctly with respect to this specific side condition.
This is the philosophy behind this test suite when testing internal
behavior of the compiler.


3.2 Naming files systematically

For convenience the test programs are named the following way:

{1 char category} + {3 char rule/restriction/derived form number} +
{1 char serial number A-Z} + "-" + {2 char compiler reaction} +
".ML"

The test programs are divided into four categories:

R    Rules. These are the main programs in the test suite. They
     test the rules as given in the Definition. The number in the
     filename equals the rule number.

S    Syntactic restrictions. These programs test that the compiler
     respects these extra restrictions. The number in the filename
     equals the point number [page 9].

D    Derived Forms. These programs test that the compiler
     implements all the derived forms as mentioned in [Appendix A].
     

M    Miscellaneous. These files test various details in SML. Se notes
     in files for further information.

The reactions indicated in the filenames can be either AC or FL
meaning that the compiler should accept or fail respectively.

Examples:

R017B-FL.ML: this program is the second program that tests rule 17
and the compiler should refuse to elaborate it.

S002A-AC.ML: this program is the first program that tests the
second point in the syntactic restrictions and the compiler should
succeed in elaborating it.


3.3 Test suite programs

Some considerations have been made in order to make it as easy as
possible to test compilers with this test suite. All programs in this
test suite are made the same way:

þ    They are all as small as possible.

þ    The programs that are meant to fail will fail in the last
     declaration of the program. This ensures that a deliberate
     error does not influence the elaboration of other tests.

þ    In all value declarations resulting in boolean variables, the
     variables are named test, test1, test2 and so forth. The
     programs are all constructed so the boolean variables should
     elaborate to true. This way, it will be obvious, that if a
     variable evaluates to false there is an error in the compiler.

þ    The programs in the rules category list the rules in (* *) that
     are used in each line. This makes the programs somewhat
     harder to read. However, it enables the reader to ensure for
     himself that the program really tests what it is meant to test.
     It also makes it possible to see which programs uses which
     rules.

þ    All the programs in the test suite contain a comment at the
     end showing the expected output from the SML compiler. Note
     however, that different SML implementations print output in
     different ways. This is why the expected output is only
     advisory. It cannot be exact for all SML implementations.

The test programs for the derived forms are constructed in a
somewhat different way. More than one derived form are tested in
the same program. This means that most of these programs are quite
long compared to the programs in the other three categories. In
these programs all declarations resulting in non-boolean variables
are hidden in local declarations. This is done to cut down on the
material needed to be examined in order to see if the compiler does
it right. As usual all the boolean variables should evaluate to true.
Furthermore, in the last declaration of the programs in this
category a variable named alltrue should evaluate to true if all the
other boolean variables are true. This way, only the variable alltrue
has to be inspected to see if the compiler elaborates and evaluates
the derived forms correctly.


3.4 Testing rule 17

In this section we will describe the test programs used to test rule
17. This description is also an example of how one can systematically
construct programs to test a given rule. These programs have not
been chosen at random of course. Rule 17 is interesting because it
concerns the value binding which is fundamental to SML. The fact
that it is the most difficult rule to test also makes it the obvious
choice of rule to describe thoroughly. It is beyond the scope of this
document to describe the development of all the programs in this
test suite in such detail.

Rule 17 concerns value declarations such as:

val pat = exp

The rule has two side conditions:

1.   VE'=ClosC,valbindVE
2.   U ï tyvars VE' = 

Each one of these side conditions is tested separately. The first test
program R017A-AC.ML tests valbindings in general. The next
programs from 
R017B-FL.ML to R17I-FL.ML test the closure of the variable
environment VE. The program R017J-FL.ML tests the second side
condition. Finally, the program R017K-FL.ML tests the scoping of
explicit type variables. Note that in the valbindings in the programs
R017A-AC.ML and R017K-FL.ML the explicit type variables scoped
here have been listed in brackets {}.


3.4.1 Test of the valbinding

R0017A-AC.ML:

val{} x = (let val{'a} Id1 : 'a -> 'a = fn z => z in Id1 Id1 end,
          let val{'a} Id2 : 'a -> 'a = fn z => z in Id2 Id2 end);

The first test program is taken directly from [page 20]. It tests the
scoping of explicit type variables. Since 'a is scoped locally at the
second value declaration, let val Id1: 'a -> 'a = fn z => z, it should
result in the variable environment VE' = {Id þ þ'a.'a  'a}. For the
same reason the third value declaration, let val Id2 : 'a -> 'a = fn z =>
z, should result in the variable environment VE' = {Id þ þ'b.'b  'b}.
Hence the applications Id1 Id1 and Id2 Id2 should elaborate.


3.4.2 Test of closure of the variable environment VE

The next programs test the different alternatives the SML compiler
has to contemplate when closing the variable environment in rule 17.
As stated [page 21], the compiler should determine whether the
expression exp is expansive or non-expansive and do the closure
operation accordingly. The type variables can be either applicative
or imperative and either free or not free in the context C. This
results in the following eight possibilities and test programs.


test program   exp              type variable  type variable   quantification
                                               in C
-----------------------------------------------------------------------------
R017B-FL.ML    non-expansive    applicative    free            no
R017C-AC.ML    non-expansive    applicative    not free        yes
R017D-AC.ML    non-expansive    imperative     not free        yes
R017E-FL.ML    non-expansive    imperative     free            no
R017F-FL.ML    expansive        applicative    free            no
R017G-AC.ML    expansive        applicative    not free        yes
R017H-FL.ML    expansive        imperative     not free        no
R017I-FL.ML    expansive        imperative     free            no



R017B-FL.ML:

val f = fn x => let
                   val y = x
                in
                   not y andalso y = 5
                end;

The valbinding, val y = x, is elaborated in the context C = C0 + {x þ
'a} where C0 is the initial context. But since 'a is free in the context
it should not be quantified in this value declaration. Therefore this
value declaration should result in the variable environment VE' = {y
þ 'a  'a}. Now 'a can be unified with bool in the expression not y
but not with int in the same expression as well. Thus the compiler
should fail to elaborate this program.


R017C-AC.ML:

val test = let
              val f = fn z => z
           in
              (f 3 = 3) andalso f true
           end;

The valbinding, val f = fn z => z, is elaborated in the context C0. But
since no type variables are free in the context and exp is non-
expansive, 'a should be quantified in this value declaration.
Therefore this value declaration should result in the variable
environment VE' = {f þ þ'a.'a  'a}. Now 'a can be unified with int in
the expression f 3 = 3 and with bool in the expression f true.


R017D-AC.ML:

let
   val f = fn x => ref x
in
   f 3 ; f true
end;

The valbinding, val f = fn x => ref x, is elaborated in the context C0.
But since no type variables are free in the context and the
expression in the valbinding, fn x => ref x, is non-expansive, 'a should
be quantified. Therefore the value declaration should result in the
variable environment VE' = {f þ þ'a.'a  'a ref}. Now 'a can be
unified with int in the expression f 3 and with bool in the
expression f true.


R017E-FL.ML:

val f = fn x => let
                   val y = ref x
                in
                   not(!y) andalso !y = 5
                end;

The valbinding, val y = ref x, is elaborated in the context C0 + {x þ
'a}. But since the type variable for x, 'a, is free in the context 'a
should not be quantified in this value declaration. Therefore this
value declaration should result in the variable environment VE' = {y
þ 'a ref}. Now 'a can be unified with bool in the expression not(!y)
but not with int in the expression !y = 5. Thus the compiler should
fail to elaborate this program.


R017F-FL.ML:

fn x => let          
           val g = (fn y => x) 5 
        in
           (g = 5.5) andalso g
        end;

The valbinding, val g = (fn y => x) 5, is elaborated in the context C0 +
{x þ 'a}. But since the type variable for x, 'a, is free in the context
C, 'a should not be quantified in this value declaration. Therefore
the value declaration should result in the variable environment VE'
= {g þ 'a}. Now 'a can be unified with real in the expression g = 5.5
but not with bool in the expression g. Thus the compiler should fail
to elaborate this program.


R017G-AC.ML:

val test = let
              val r = (fn x => (x, ref [])) (fn y => y)
           in
              let
                 val (f,y) = r
              in
                 f 3 = 3 andalso f true andalso ( y := [1]; [1] = !y)
              end
           end;

The valbinding, val r = (fn x => (x, ref [])) (fn y => y), is elaborated in
the context C0. But since no type variables are free in the context
C, the applicative type variable 'a should be quantified. Therefore
this value declaration should give the variable environment VE' = {r
þ þ'a.('a  'a) * 'b list ref }. Now 'a can be unified with int in the
expression f 3 = 3 and also with bool in the expression f true. 


R017H-FL.ML:

val test = let
              val r = (fn x => (x, ref [])) (fn y => y)
           in
              let
                 val (f,y) = r
              in
                 f 3 = 3
                 andalso f true
                 andalso (y := [1]; [1] = !y)
                 andalso (y := [true]; [true] = !y)
              end
           end;

The valbinding, val r = (fn x => (x, ref [])) (fn y => y), is elaborated in
the context C0. But since the type of ref [] contains an imperative
type variable 'b and the expression is expansive 'b should not be
quantified in this value declaration. Therefore this value declaration
should result in the variable environment VE' = {r þ þ'a.('a  'a) *
'b list ref }. The program should not elaborate since 'b can not be
unified with int list in the expression y := [1] and also with bool
list in the expression y := [true]. Thus the compiler should fail to
elaborate this program.


R017I-FL.ML:

val f = fn x => let
                   val y = ref x
                in
                   y := 1 ; y := true
                end;

The valbinding, val y = ref x, is elaborated in the context C0 + {x þ
'a}. But since 'a is free in this context 'a should not be quantified
in this value declaration. Therefore the value declaration should
result in the variable environment VE' = {y þ 'a ref}. The program
should not elaborate since 'a cannot be unified with int in the
expression y := 1 and also with bool in the expression y := true.
Thus the compiler should fail to elaborate this program.


R017J-FL.ML:

fn x => let
           val{'a} y : 'a = x
        in
           y
        end;

In this program 'a is scoped at the val declaration, val{'a} y : 'a = x.
The declaration is elaborated in the context C0 + {x þ 'b}. But since
the value declaration sets y equal to x the two type variables, 'a
and 'b, must also be the same. This breaks the second side
condition of rule 17 (U ï tyvars VE' = ). Thus the program should
not elaborate.

R017K-FL.ML:

val{'a} x = (let val{} Id : 'a -> 'a = fn z => z in Id Id end,
           fn z => z : 'a);

This program is taken from [page 20]. It tests the scoping of
explicit type variables. The type variable 'a is scoped at the outer
value declaration. This means that the valbinding, val{} Id : 'a -> 'a =
fn z => z, elaborates into VE = {Id þ 'a  'a}. This way Id can not
occur in two different instantiations in the expression Id Id. Thus
the program should not elaborate.


4.0 Using the test suite





The testing of a compiler with this test suite can not be made
automatically. However, the work is made somewhat easier by the
accessory files provided with it. For testing compilers running
under MS-DOS the following batch files are provided:

TEST_ALL.BAT   Runs all the test programs on the compiler and
               directs the output into a subdirectory called
               LOGFILES.

TEST_ONE.BAT   Runs one test program on a compiler. The user
               should change the contents of this file with the
               name of the compiler to be tested. Used by
               TEST_ALL.BAT.

SHOW_ALL.BAT   Shows all the test programs one by one with the
               result from the compiler. This makes it possible to
               compare the actual results with the expected
               results to see if the compiler has elaborated and
               evaluated the programs correctly.

SHOW_ONE.BAT   Used by SHOW_ALL.BAT to show one test program
               along with the output from the compiler.

For testing compilers running under UNIX the script TEST_ALL.S is
provided. The command:

sh TEST_ALL.S > compiler.log

runs the compiler with all the test programs and stores all the
output into the file compiler.log. 

Please note that it is very important that the output from the
compiler is carefully examined. It should be checked that the output
from the compiler matches the expected results. This does not mean
that the compiler should give the same results syntactically but
semantically. The test results from the failing programs should be
examined closely to see if an error message really is a result of a
deliberate error in a program.

5.0 Conclusion





As stated in the introduction it is not possible to prove that a
Standard ML implementation, or any other program for that matter,
works as intended to do by using it on test data. For example, one
cannot ensure that a every new datatype in a SML program is really
assigned a new internal type in the SML implementation (rule 29).
Also, one cannot test the internal interpretation of a SML program.
This is why, for example, it is not possible to ensure that derived
forms are interpreted correctly. One can create a number of test
programs containing derived forms and examine if they behave as
expected. But one cannot really check that the derived forms are
interpreted correctly internally in the SML implementation. Even
though the compiler handles the examples correctly one will never
know if the compiler will handle all other instances of the derived
forms correctly as well.

So is the approach used in this project appropriate, e.g. is
systematical testing based on the rules from the Definition the best
way to test a SML implementation? We think so for the following
reasons: 

þ    SML is very precisely mathematically defined which in itself
     makes it possible to use a systematic approach.

þ    by systematically testing rule by rule chances are that one
     gets to test things that might otherwise not be thought of.

þ    by testing one thing at a time in separate programs one
     ensures that a failure to elaborate or evaluate a declaration is
     not a side effect of a previous declaration.

þ    we have found a number of errors in different SML
     implementations.

The question then is if we have found more errors than we would
by testing at random. We are convinced that we actually have. The
arguments are the same as above plus the fact that this test suite
makes it very easy to compare expected results with actual results.
Also by constructing test programs at random chances are that
different programs might actually test the same thing. One would
have to check the Definition to see what a program actually tested.
This approach could lead to much more work.

Having said this about the systematical approach we should add, as
stated before, that intuition was also a part of the development of
the programs in this test suite, e.g. the rules in the Definition
cannot be translated directly into programs. The construction of a
program for a specific rule or a side condition sometimes required a
lot of effort.

Finally, we would like to reemphasize that an exhaustive test is
impossible using test data. If a SML implementation elaborates (and
evaluates) all programs in this test suite correctly it may of course
still contain errors.

Bibliography





[1]  Robin Milner, Mads Tofte, and Robin Harper. The Definition of
     Standard ML. MIT Press, 1990.

[2]  Robin Milner and Mads Tofte. Commentary on Standard ML. MIT
     Press, 1991.

[3]  Chris Reade. Elements of functional programming. Addison-
     Wesley Publishers Ltd, 1989.

[4]  Robert Harper. Introduction to Standard ML. School of
     Computer Science, Carnegie Mellon University, 1990.


A. Which rules are used in which files





The following list shows which rules are used in which files. Each of
the rules 1-22, 24-52 is followed by a list of the files in which a
rule is used at least once. As it can be seen from the list, all the
rules 1-22, 24-52 are used in the test suite.


Rule   1:
R005A-AC.ML, R005B-FL.ML, R005C-FL.ML, R006A-AC.ML, R007A-AC.ML, R008A-AC.ML, 
R010A-AC.ML, R010B-FL.ML, R011A-AC.ML, R011B-FL.ML, R011D-FL.ML, R012A-AC.ML, 
R012B-FL.ML, R012C-FL.ML, R013A-AC.ML, R014A-AC.ML, R015A-AC.ML, R015B-FL.ML, 
R015C-FL.ML, R016A-AC.ML, R016B-AC.ML, R017B-FL.ML, R017C-AC.ML, R017E-FL.ML, 
R017F-FL.ML, R017G-AC.ML, R017I-FL.ML, R018A-AC.ML, R020A-AC.ML, R020B-FL.ML, 
R020C-FL.ML, R021A-AC.ML, R021B-FL.ML, R022A-AC.ML, R022B-AC.ML, R022C-FL.ML, 
R024A-AC.ML, R025A-AC.ML, R026A-FL.ML, R026B-FL.ML, R027A-AC.ML, R027B-AC.ML, 
R027C-FL.ML, R028A-AC.ML, R029A-AC.ML, R029B-AC.ML, R030A-AC.ML, R031A-AC.ML, 
R031B-FL.ML, R031C-FL.ML, R034A-AC.ML, R034B-AC.ML, R035A-AC.ML, R038A-AC.ML, 
R039A-AC.ML, R041A-AC.ML, R043A-AC.ML, R043B-FL.ML, R044A-AC.ML, R044B-FL.ML, 
R045A-AC.ML, R045B-FL.ML, R046A-AC.ML, R046B-FL.ML, R048A-AC.ML, R049A-AC.ML, 
R049B-FL.ML, 

Rule   2:
R002A-FL.ML, R005A-AC.ML, R005B-FL.ML, R005C-FL.ML, R006A-AC.ML, R006B-FL.ML, 
R006C-FL.ML, R007A-AC.ML, R008A-AC.ML, R010A-AC.ML, R010B-FL.ML, R011A-AC.ML, 
R011E-FL.ML, R013A-AC.ML, R014A-AC.ML, R015A-AC.ML, R015B-FL.ML, R015C-FL.ML, 
R016B-AC.ML, R017A-AC.ML, R017B-FL.ML, R017C-AC.ML, R017D-AC.ML, R017E-FL.ML, 
R017F-FL.ML, R017G-AC.ML, R017H-FL.ML, R017I-FL.ML, R017J-FL.ML, R017K-FL.ML, 
R018A-AC.ML, R019A-AC.ML, R019B-AC.ML, R019C-FL.ML, R019D-AC.ML, R020A-AC.ML, 
R020B-FL.ML, R020C-FL.ML, R020D-AC.ML, R022A-AC.ML, R022B-AC.ML, R022C-FL.ML, 
R024A-AC.ML, R025A-AC.ML, R026B-FL.ML, R027A-AC.ML, R027B-AC.ML, R027C-FL.ML, 
R027D-FL.ML, R028A-AC.ML, R028B-AC.ML, R028C-AC.ML, R029C-FL.ML, R031A-AC.ML, 
R034A-AC.ML, R034B-AC.ML, R034C-AC.ML, R036A-AC.ML, R038A-AC.ML, R039A-AC.ML, 
R041A-AC.ML, R043A-AC.ML, R043B-FL.ML, R044A-AC.ML, R044B-FL.ML, R045A-AC.ML, 
R045B-FL.ML, R046A-AC.ML, R046B-FL.ML, R050A-AC.ML, R050B-FL.ML, R052A-AC.ML, 

Rule   3:
R003A-FL.ML, R005A-AC.ML, R005B-FL.ML, R006A-AC.ML, R006B-FL.ML, R006C-FL.ML, 
R008A-AC.ML, R010A-AC.ML, R011A-AC.ML, R011B-FL.ML, R011C-FL.ML, R013A-AC.ML, 
R017C-AC.ML, R017D-AC.ML, R017E-FL.ML, R017G-AC.ML, R017H-FL.ML, R017I-FL.ML, 
R019A-AC.ML, R019B-AC.ML, R019C-FL.ML, R019D-AC.ML, R020A-AC.ML, R020B-FL.ML, 
R020C-FL.ML, R020D-AC.ML, R022A-AC.ML, R022B-AC.ML, R025B-FL.ML, R027D-FL.ML, 
R028B-AC.ML, R029A-AC.ML, R029B-AC.ML, R029C-FL.ML, R029D-FL.ML, R030A-AC.ML, 
R031A-AC.ML, R031B-FL.ML, R031C-FL.ML, R034A-AC.ML, R034C-AC.ML, R035A-AC.ML, 
R036A-AC.ML, R038A-AC.ML, R041A-AC.ML, R043A-AC.ML, R043B-FL.ML, R044A-AC.ML, 
R044B-FL.ML, R045A-AC.ML, R045B-FL.ML, R046A-AC.ML, R046B-FL.ML, R048A-AC.ML, 
R049A-AC.ML, R049B-FL.ML, R050A-AC.ML, R052A-AC.ML, R100A-FL.ML, 

Rule   4:
R013A-AC.ML, R013B-FL.ML, R021A-AC.ML, R044A-AC.ML, 

Rule   5:
R005A-AC.ML, R005B-FL.ML, R005C-FL.ML, R006B-FL.ML, R006C-FL.ML, R007A-AC.ML, 
R008A-AC.ML, R010A-AC.ML, R010B-FL.ML, R011A-AC.ML, R011B-FL.ML, R013A-AC.ML, 
R015B-FL.ML, R017A-AC.ML, R017B-FL.ML, R017C-AC.ML, R017E-FL.ML, R017F-FL.ML, 
R017G-AC.ML, R017H-FL.ML, R017I-FL.ML, R017K-FL.ML, R018A-AC.ML, R019A-AC.ML, 
R019B-AC.ML, R019C-FL.ML, R019D-AC.ML, R020A-AC.ML, R020B-FL.ML, R020C-FL.ML, 
R020D-AC.ML, R022A-AC.ML, R022B-AC.ML, R022C-FL.ML, R025A-AC.ML, R027A-AC.ML, 
R027B-AC.ML, R027C-FL.ML, R027D-FL.ML, R028A-AC.ML, R029A-AC.ML, R029B-AC.ML, 
R029C-FL.ML, R030A-AC.ML, R034A-AC.ML, R034B-AC.ML, R034C-AC.ML, R035A-AC.ML, 
R038A-AC.ML, R039A-AC.ML, R041A-AC.ML, R043A-AC.ML, R043B-FL.ML, R044A-AC.ML, 
R044B-FL.ML, R045A-AC.ML, R045B-FL.ML, R046A-AC.ML, R046B-FL.ML, R048A-AC.ML, 
R049A-AC.ML, R049B-FL.ML, R050A-AC.ML, R050B-FL.ML, R052A-AC.ML, 

Rule   6:
R006A-AC.ML, R006B-FL.ML, R006C-FL.ML, R010B-FL.ML, R017A-AC.ML, R017B-FL.ML, 
R017C-AC.ML, R017D-AC.ML, R017E-FL.ML, R017F-FL.ML, R017G-AC.ML, R017H-FL.ML, 
R017I-FL.ML, R017J-FL.ML, R019B-AC.ML, R019C-FL.ML, R019D-AC.ML, R024A-AC.ML, 
R025B-FL.ML, R029B-AC.ML, R031B-FL.ML, R031C-FL.ML, 

Rule   7:
R005A-AC.ML, R005B-FL.ML, R005C-FL.ML, R007A-AC.ML, R008A-AC.ML, R010B-FL.ML, 
R011A-AC.ML, R011E-FL.ML, R013A-AC.ML, R014A-AC.ML, R017C-AC.ML, R017F-FL.ML, 
R017G-AC.ML, R017H-FL.ML, R019A-AC.ML, R020A-AC.ML, R020B-FL.ML, R020C-FL.ML, 
R025A-AC.ML, R027A-AC.ML, R027B-AC.ML, R027C-FL.ML, R031A-AC.ML, R031B-FL.ML, 

Rule   8:
R005A-AC.ML, R005B-FL.ML, R005C-FL.ML, R006B-FL.ML, R006C-FL.ML, R007A-AC.ML, 
R008A-AC.ML, R010A-AC.ML, R010B-FL.ML, R011A-AC.ML, R011B-FL.ML, R013A-AC.ML, 
R015B-FL.ML, R017A-AC.ML, R017B-FL.ML, R017C-AC.ML, R017E-FL.ML, R017F-FL.ML, 
R017G-AC.ML, R017H-FL.ML, R017I-FL.ML, R017K-FL.ML, R018A-AC.ML, R019A-AC.ML, 
R019B-AC.ML, R019C-FL.ML, R019D-AC.ML, R020A-AC.ML, R020B-FL.ML, R020C-FL.ML, 
R020D-AC.ML, R022A-AC.ML, R022B-AC.ML, R022C-FL.ML, R025A-AC.ML, R027A-AC.ML, 
R027B-AC.ML, R027C-FL.ML, R027D-FL.ML, R028A-AC.ML, R029A-AC.ML, R029B-AC.ML, 
R029C-FL.ML, R030A-AC.ML, R034A-AC.ML, R034B-AC.ML, R034C-AC.ML, R035A-AC.ML, 
R038A-AC.ML, R039A-AC.ML, R041A-AC.ML, R043A-AC.ML, R043B-FL.ML, R044A-AC.ML, 
R044B-FL.ML, R045A-AC.ML, R045B-FL.ML, R046A-AC.ML, R046B-FL.ML, R048A-AC.ML, 
R049A-AC.ML, R049B-FL.ML, R050A-AC.ML, R050B-FL.ML, R052A-AC.ML, 

Rule   9:
R002A-FL.ML, R003A-FL.ML, R005A-AC.ML, R005B-FL.ML, R005C-FL.ML, R006A-AC.ML, 
R006B-FL.ML, R006C-FL.ML, R007A-AC.ML, R008A-AC.ML, R010A-AC.ML, R010B-FL.ML, 
R011A-AC.ML, R011B-FL.ML, R011C-FL.ML, R011D-FL.ML, R011E-FL.ML, R012A-AC.ML, 
R012B-FL.ML, R012C-FL.ML, R013A-AC.ML, R013B-FL.ML, R014A-AC.ML, R015A-AC.ML, 
R015B-FL.ML, R015C-FL.ML, R016A-AC.ML, R016B-AC.ML, R017A-AC.ML, R017B-FL.ML, 
R017C-AC.ML, R017D-AC.ML, R017E-FL.ML, R017F-FL.ML, R017G-AC.ML, R017H-FL.ML, 
R017I-FL.ML, R017J-FL.ML, R017K-FL.ML, R018A-AC.ML, R019A-AC.ML, R019B-AC.ML, 
R019C-FL.ML, R019D-AC.ML, R020A-AC.ML, R020B-FL.ML, R020C-FL.ML, R020D-AC.ML, 
R021A-AC.ML, R021B-FL.ML, R022A-AC.ML, R022B-AC.ML, R022C-FL.ML, R024A-AC.ML, 
R025A-AC.ML, R025B-FL.ML, R026A-FL.ML, R026B-FL.ML, R027A-AC.ML, R027B-AC.ML, 
R027C-FL.ML, R027D-FL.ML, R028A-AC.ML, R028B-AC.ML, R028C-AC.ML, R029A-AC.ML, 
R029B-AC.ML, R029C-FL.ML, R029D-FL.ML, R030A-AC.ML, R031A-AC.ML, R031B-FL.ML, 
R031C-FL.ML, R034A-AC.ML, R034B-AC.ML, R034C-AC.ML, R035A-AC.ML, R036A-AC.ML, 
R038A-AC.ML, R039A-AC.ML, R041A-AC.ML, R043A-AC.ML, R043B-FL.ML, R044A-AC.ML, 
R044B-FL.ML, R045A-AC.ML, R045B-FL.ML, R046A-AC.ML, R046B-FL.ML, R048A-AC.ML, 
R049A-AC.ML, R049B-FL.ML, R050A-AC.ML, R050B-FL.ML, R052A-AC.ML, R100A-FL.ML, 

Rule  10:
R005A-AC.ML, R005B-FL.ML, R005C-FL.ML, R006B-FL.ML, R006C-FL.ML, R007A-AC.ML, 
R008A-AC.ML, R010A-AC.ML, R010B-FL.ML, R011A-AC.ML, R013A-AC.ML, R014A-AC.ML, 
R015B-FL.ML, R016B-AC.ML, R017A-AC.ML, R017B-FL.ML, R017C-AC.ML, R017D-AC.ML, 
R017E-FL.ML, R017F-FL.ML, R017G-AC.ML, R017H-FL.ML, R017I-FL.ML, R017K-FL.ML, 
R018A-AC.ML, R019A-AC.ML, R019B-AC.ML, R019C-FL.ML, R019D-AC.ML, R020A-AC.ML, 
R020B-FL.ML, R020C-FL.ML, R020D-AC.ML, R021A-AC.ML, R022A-AC.ML, R022B-AC.ML, 
R022C-FL.ML, R025A-AC.ML, R027A-AC.ML, R027B-AC.ML, R027C-FL.ML, R027D-FL.ML, 
R028A-AC.ML, R028B-AC.ML, R029A-AC.ML, R029B-AC.ML, R029C-FL.ML, R030A-AC.ML, 
R031A-AC.ML, R031B-FL.ML, R031C-FL.ML, R039A-AC.ML, R041A-AC.ML, R043A-AC.ML, 
R043B-FL.ML, R044A-AC.ML, R044B-FL.ML, R100A-FL.ML, 

Rule  11:
R011A-AC.ML, R011B-FL.ML, R011D-FL.ML, R011E-FL.ML, R014A-AC.ML, R016B-AC.ML, 
R017K-FL.ML, R020A-AC.ML, R025B-FL.ML, R048A-AC.ML, R049A-AC.ML, R049B-FL.ML, 

Rule  12:
R012A-AC.ML, R012B-FL.ML, R012C-FL.ML, R013A-AC.ML, R031A-AC.ML, R031B-FL.ML, 

Rule  13:
R013A-AC.ML, R013B-FL.ML, R031A-AC.ML, R031B-FL.ML, 

Rule  14:
R008A-AC.ML, R011E-FL.ML, R014A-AC.ML, R015A-AC.ML, R015B-FL.ML, R015C-FL.ML, 
R016A-AC.ML, R016B-AC.ML, R017A-AC.ML, R017B-FL.ML, R017C-AC.ML, R017D-AC.ML, 
R017E-FL.ML, R017F-FL.ML, R017G-AC.ML, R017H-FL.ML, R017I-FL.ML, R017J-FL.ML, 
R017K-FL.ML, R020A-AC.ML, R020B-FL.ML, R020C-FL.ML, R022A-AC.ML, R022B-AC.ML, 
R022C-FL.ML, R027A-AC.ML, R027B-AC.ML, R027C-FL.ML, R027D-FL.ML, R028B-AC.ML, 
R034C-AC.ML, R036A-AC.ML, R050A-AC.ML, R050B-FL.ML, R052A-AC.ML, 

Rule  15:
R008A-AC.ML, R011E-FL.ML, R012A-AC.ML, R012B-FL.ML, R012C-FL.ML, R013A-AC.ML, 
R014A-AC.ML, R015A-AC.ML, R015B-FL.ML, R015C-FL.ML, R016A-AC.ML, R016B-AC.ML, 
R017A-AC.ML, R017B-FL.ML, R017C-AC.ML, R017D-AC.ML, R017E-FL.ML, R017F-FL.ML, 
R017G-AC.ML, R017H-FL.ML, R017I-FL.ML, R017J-FL.ML, R017K-FL.ML, R020A-AC.ML, 
R020B-FL.ML, R020C-FL.ML, R022A-AC.ML, R022B-AC.ML, R022C-FL.ML, R027A-AC.ML, 
R027B-AC.ML, R027C-FL.ML, R027D-FL.ML, R028B-AC.ML, R031A-AC.ML, R031B-FL.ML, 
R034C-AC.ML, R036A-AC.ML, R050A-AC.ML, R050B-FL.ML, R052A-AC.ML, 

Rule  16:
R008A-AC.ML, R011E-FL.ML, R012A-AC.ML, R012B-FL.ML, R012C-FL.ML, R013A-AC.ML, 
R014A-AC.ML, R015A-AC.ML, R015B-FL.ML, R015C-FL.ML, R016A-AC.ML, R016B-AC.ML, 
R017A-AC.ML, R017B-FL.ML, R017C-AC.ML, R017D-AC.ML, R017E-FL.ML, R017F-FL.ML, 
R017G-AC.ML, R017H-FL.ML, R017I-FL.ML, R017J-FL.ML, R017K-FL.ML, R020A-AC.ML, 
R020B-FL.ML, R020C-FL.ML, R022A-AC.ML, R022B-AC.ML, R022C-FL.ML, R027A-AC.ML, 
R027B-AC.ML, R027C-FL.ML, R027D-FL.ML, R028B-AC.ML, R031A-AC.ML, R031B-FL.ML, 
R034C-AC.ML, R036A-AC.ML, R050A-AC.ML, R050B-FL.ML, R052A-AC.ML, 

Rule  17:
R002A-FL.ML, R003A-FL.ML, R005A-AC.ML, R005B-FL.ML, R005C-FL.ML, R006A-AC.ML, 
R006B-FL.ML, R006C-FL.ML, R007A-AC.ML, R008A-AC.ML, R010A-AC.ML, R010B-FL.ML, 
R011A-AC.ML, R011B-FL.ML, R011C-FL.ML, R011D-FL.ML, R011E-FL.ML, R012A-AC.ML, 
R012B-FL.ML, R012C-FL.ML, R013A-AC.ML, R013B-FL.ML, R014A-AC.ML, R015A-AC.ML, 
R015B-FL.ML, R015C-FL.ML, R016A-AC.ML, R016B-AC.ML, R017A-AC.ML, R017B-FL.ML, 
R017C-AC.ML, R017D-AC.ML, R017E-FL.ML, R017F-FL.ML, R017G-AC.ML, R017H-FL.ML, 
R017I-FL.ML, R017J-FL.ML, R017K-FL.ML, R018A-AC.ML, R019A-AC.ML, R019B-AC.ML, 
R019C-FL.ML, R019D-AC.ML, R020A-AC.ML, R020B-FL.ML, R020C-FL.ML, R020D-AC.ML, 
R021A-AC.ML, R021B-FL.ML, R022A-AC.ML, R022B-AC.ML, R022C-FL.ML, R024A-AC.ML, 
R025A-AC.ML, R025B-FL.ML, R026A-FL.ML, R026B-FL.ML, R027A-AC.ML, R027B-AC.ML, 
R027C-FL.ML, R027D-FL.ML, R028A-AC.ML, R028B-AC.ML, R028C-AC.ML, R029A-AC.ML, 
R029B-AC.ML, R029C-FL.ML, R029D-FL.ML, R030A-AC.ML, R031A-AC.ML, R031B-FL.ML, 
R031C-FL.ML, R034A-AC.ML, R034B-AC.ML, R034C-AC.ML, R035A-AC.ML, R036A-AC.ML, 
R038A-AC.ML, R039A-AC.ML, R041A-AC.ML, R043A-AC.ML, R043B-FL.ML, R044A-AC.ML, 
R044B-FL.ML, R045A-AC.ML, R045B-FL.ML, R046A-AC.ML, R046B-FL.ML, R048A-AC.ML, 
R049A-AC.ML, R049B-FL.ML, R050A-AC.ML, R050B-FL.ML, R052A-AC.ML, R100A-FL.ML, 

Rule  18:
R018A-AC.ML, R028A-AC.ML, R028B-AC.ML, R028C-AC.ML, R028D-FL.ML, R029A-AC.ML, 
R048A-AC.ML, R049A-AC.ML, R049B-FL.ML, R050A-AC.ML, R050B-FL.ML, R052A-AC.ML, 

Rule  19:
R006C-FL.ML, R012C-FL.ML, R013B-FL.ML, R019A-AC.ML, R019B-AC.ML, R019C-FL.ML, 
R019D-AC.ML, R025B-FL.ML, R029A-AC.ML, R029B-AC.ML, R029C-FL.ML, R029D-FL.ML, 
R029E-AC.ML, R030A-AC.ML, R041A-AC.ML, R043A-AC.ML, R043B-FL.ML, 

Rule  20:
R020A-AC.ML, R020B-FL.ML, R020C-FL.ML, R020D-AC.ML, 

Rule  21:
R012A-AC.ML, R012B-FL.ML, R013A-AC.ML, R021A-AC.ML, R021B-FL.ML, R031A-AC.ML, 
R031B-FL.ML, R031C-FL.ML, R032A-AC.ML, R041A-AC.ML, R044A-AC.ML, R044B-FL.ML, 
R052A-AC.ML, 

Rule  22:
R022A-AC.ML, R022B-AC.ML, R022C-FL.ML, R024A-AC.ML, 

Rule  24:
R017D-AC.ML, R017I-FL.ML, R024A-AC.ML, 

Rule  25:
R017D-AC.ML, R017G-AC.ML, R017I-FL.ML, R024A-AC.ML, R025B-FL.ML, 

Rule  26:
R002A-FL.ML, R003A-FL.ML, R005A-AC.ML, R005B-FL.ML, R005C-FL.ML, R006A-AC.ML, 
R006B-FL.ML, R006C-FL.ML, R007A-AC.ML, R008A-AC.ML, R010A-AC.ML, R010B-FL.ML, 
R011A-AC.ML, R011B-FL.ML, R011C-FL.ML, R011D-FL.ML, R011E-FL.ML, R012A-AC.ML, 
R012B-FL.ML, R012C-FL.ML, R013A-AC.ML, R013B-FL.ML, R014A-AC.ML, R015A-AC.ML, 
R015B-FL.ML, R015C-FL.ML, R016A-AC.ML, R016B-AC.ML, R017A-AC.ML, R017B-FL.ML, 
R017C-AC.ML, R017D-AC.ML, R017E-FL.ML, R017F-FL.ML, R017G-AC.ML, R017H-FL.ML, 
R017I-FL.ML, R017J-FL.ML, R017K-FL.ML, R018A-AC.ML, R019A-AC.ML, R019B-AC.ML, 
R019C-FL.ML, R019D-AC.ML, R020A-AC.ML, R020B-FL.ML, R020C-FL.ML, R020D-AC.ML, 
R021A-AC.ML, R021B-FL.ML, R022A-AC.ML, R022B-AC.ML, R022C-FL.ML, R024A-AC.ML, 
R025A-AC.ML, R025B-FL.ML, R026A-FL.ML, R026B-FL.ML, R027A-AC.ML, R027B-AC.ML, 
R027C-FL.ML, R028A-AC.ML, R028B-AC.ML, R028C-AC.ML, R029A-AC.ML, R029B-AC.ML, 
R029C-FL.ML, R029D-FL.ML, R030A-AC.ML, R031A-AC.ML, R031B-FL.ML, R031C-FL.ML, 
R034A-AC.ML, R034B-AC.ML, R034C-AC.ML, R035A-AC.ML, R036A-AC.ML, R038A-AC.ML, 
R039A-AC.ML, R041A-AC.ML, R043A-AC.ML, R043B-FL.ML, R044A-AC.ML, R044B-FL.ML, 
R045A-AC.ML, R045B-FL.ML, R046A-AC.ML, R046B-FL.ML, R048A-AC.ML, R049A-AC.ML, 
R049B-FL.ML, R050A-AC.ML, R050B-FL.ML, R052A-AC.ML, R100A-FL.ML, 

Rule  27:
R020A-AC.ML, R020B-FL.ML, R020C-FL.ML, R027A-AC.ML, R027D-FL.ML, 

Rule  28:
R018A-AC.ML, R028A-AC.ML, R028B-AC.ML, R028C-AC.ML, R028D-FL.ML, R029A-AC.ML, 
R048A-AC.ML, R049A-AC.ML, R049B-FL.ML, R050B-FL.ML, R052A-AC.ML, 

Rule  29:
R006C-FL.ML, R012C-FL.ML, R013B-FL.ML, R019A-AC.ML, R019B-AC.ML, R019C-FL.ML, 
R019D-AC.ML, R020A-AC.ML, R020B-FL.ML, R020C-FL.ML, R020D-AC.ML, R025B-FL.ML, 
R029A-AC.ML, R029B-AC.ML, R029C-FL.ML, R029D-FL.ML, R029E-AC.ML, R030A-AC.ML, 
R041A-AC.ML, R043A-AC.ML, R043B-FL.ML, 

Rule  30:
R006C-FL.ML, R012C-FL.ML, R013B-FL.ML, R019A-AC.ML, R019B-AC.ML, R019C-FL.ML, 
R019D-AC.ML, R020A-AC.ML, R020B-FL.ML, R020C-FL.ML, R020D-AC.ML, R029A-AC.ML, 
R029B-AC.ML, R029C-FL.ML, R029D-FL.ML, R029E-AC.ML, R030A-AC.ML, R041A-AC.ML, 
R043A-AC.ML, R043B-FL.ML, 

Rule  31:
R012A-AC.ML, R012B-FL.ML, R013A-AC.ML, R021A-AC.ML, R021B-FL.ML, R031A-AC.ML, 
R031B-FL.ML, R031C-FL.ML, R032A-AC.ML, R041A-AC.ML, R044A-AC.ML, R044B-FL.ML, 
R052A-AC.ML, 

Rule  32:
R032A-AC.ML, 

Rule  33:
R036A-AC.ML, R043A-AC.ML, R043B-FL.ML, 

Rule  34:
R027A-AC.ML, R027B-AC.ML, R027C-FL.ML, R031A-AC.ML, R031B-FL.ML, R034B-AC.ML, 

Rule  35:
R002A-FL.ML, R003A-FL.ML, R005A-AC.ML, R005B-FL.ML, R005C-FL.ML, R006A-AC.ML, 
R006B-FL.ML, R006C-FL.ML, R007A-AC.ML, R008A-AC.ML, R010A-AC.ML, R010B-FL.ML, 
R011A-AC.ML, R011B-FL.ML, R011C-FL.ML, R011D-FL.ML, R011E-FL.ML, R012A-AC.ML, 
R012B-FL.ML, R012C-FL.ML, R013A-AC.ML, R013B-FL.ML, R014A-AC.ML, R015A-AC.ML, 
R015B-FL.ML, R015C-FL.ML, R016A-AC.ML, R016B-AC.ML, R017A-AC.ML, R017B-FL.ML, 
R017C-AC.ML, R017D-AC.ML, R017E-FL.ML, R017F-FL.ML, R017G-AC.ML, R017H-FL.ML, 
R017I-FL.ML, R017J-FL.ML, R017K-FL.ML, R018A-AC.ML, R019A-AC.ML, R019B-AC.ML, 
R019C-FL.ML, R019D-AC.ML, R020A-AC.ML, R020B-FL.ML, R020C-FL.ML, R020D-AC.ML, 
R021A-AC.ML, R022A-AC.ML, R022B-AC.ML, R022C-FL.ML, R024A-AC.ML, R025A-AC.ML, 
R025B-FL.ML, R026B-FL.ML, R027A-AC.ML, R027B-AC.ML, R027C-FL.ML, R027D-FL.ML, 
R028A-AC.ML, R028B-AC.ML, R028C-AC.ML, R028D-FL.ML, R029A-AC.ML, R029B-AC.ML, 
R029C-FL.ML, R029D-FL.ML, R030A-AC.ML, R031A-AC.ML, R031B-FL.ML, R031C-FL.ML, 
R034A-AC.ML, R034B-AC.ML, R034C-AC.ML, R035A-AC.ML, R036A-AC.ML, R038A-AC.ML, 
R039A-AC.ML, R041A-AC.ML, R043A-AC.ML, R043B-FL.ML, R044A-AC.ML, R044B-FL.ML, 
R045A-AC.ML, R045B-FL.ML, R046A-AC.ML, R046B-FL.ML, R048A-AC.ML, R049A-AC.ML, 
R049B-FL.ML, R050A-AC.ML, R050B-FL.ML, R052A-AC.ML, R100A-FL.ML, 

Rule  36:
R015A-AC.ML, R015C-FL.ML, R016A-AC.ML, R027D-FL.ML, R031A-AC.ML, R034A-AC.ML, 
R034C-AC.ML, R036A-AC.ML, R044B-FL.ML, 

Rule  37:
R012A-AC.ML, R012B-FL.ML, R012C-FL.ML, R013A-AC.ML, R021B-FL.ML, 

Rule  38:
R008A-AC.ML, R017G-AC.ML, R017H-FL.ML, R020A-AC.ML, R020B-FL.ML, R020C-FL.ML, 
R027D-FL.ML, R031A-AC.ML, R034A-AC.ML, R034B-AC.ML, R034C-AC.ML, R036A-AC.ML, 
R038A-AC.ML, R041A-AC.ML, R043A-AC.ML, R043B-FL.ML, R044A-AC.ML, R044B-FL.ML, 
R045A-AC.ML, R045B-FL.ML, R046A-AC.ML, R046B-FL.ML, 

Rule  39:
R020A-AC.ML, R020B-FL.ML, R020C-FL.ML, R027D-FL.ML, R039A-AC.ML, 

Rule  40:
R008A-AC.ML, R038A-AC.ML, R041A-AC.ML, R044B-FL.ML, R045A-AC.ML, R045B-FL.ML, 

Rule  41:
R008A-AC.ML, R017G-AC.ML, R017H-FL.ML, R020A-AC.ML, R020B-FL.ML, R020C-FL.ML, 
R027D-FL.ML, R031A-AC.ML, R034A-AC.ML, R034B-AC.ML, R034C-AC.ML, R036A-AC.ML, 
R038A-AC.ML, R041A-AC.ML, R043A-AC.ML, R043B-FL.ML, R044A-AC.ML, R044B-FL.ML, 
R045A-AC.ML, R045B-FL.ML, R046A-AC.ML, R046B-FL.ML, 

Rule  42:
R002A-FL.ML, R003A-FL.ML, R005A-AC.ML, R005B-FL.ML, R005C-FL.ML, R006A-AC.ML, 
R006B-FL.ML, R006C-FL.ML, R007A-AC.ML, R008A-AC.ML, R010A-AC.ML, R010B-FL.ML, 
R011A-AC.ML, R011B-FL.ML, R011C-FL.ML, R011D-FL.ML, R011E-FL.ML, R012A-AC.ML, 
R012B-FL.ML, R012C-FL.ML, R013A-AC.ML, R013B-FL.ML, R014A-AC.ML, R015A-AC.ML, 
R015B-FL.ML, R015C-FL.ML, R016A-AC.ML, R016B-AC.ML, R017A-AC.ML, R017B-FL.ML, 
R017C-AC.ML, R017D-AC.ML, R017E-FL.ML, R017F-FL.ML, R017G-AC.ML, R017H-FL.ML, 
R017I-FL.ML, R017J-FL.ML, R017K-FL.ML, R018A-AC.ML, R019A-AC.ML, R019B-AC.ML, 
R019C-FL.ML, R019D-AC.ML, R020A-AC.ML, R020B-FL.ML, R020C-FL.ML, R020D-AC.ML, 
R021A-AC.ML, R022A-AC.ML, R022B-AC.ML, R022C-FL.ML, R024A-AC.ML, R025A-AC.ML, 
R025B-FL.ML, R026B-FL.ML, R027A-AC.ML, R027B-AC.ML, R027C-FL.ML, R027D-FL.ML, 
R028A-AC.ML, R028B-AC.ML, R028C-AC.ML, R028D-FL.ML, R029A-AC.ML, R029B-AC.ML, 
R029C-FL.ML, R029D-FL.ML, R030A-AC.ML, R031A-AC.ML, R031B-FL.ML, R031C-FL.ML, 
R034A-AC.ML, R034B-AC.ML, R034C-AC.ML, R035A-AC.ML, R036A-AC.ML, R038A-AC.ML, 
R039A-AC.ML, R041A-AC.ML, R043A-AC.ML, R043B-FL.ML, R044A-AC.ML, R044B-FL.ML, 
R045A-AC.ML, R045B-FL.ML, R046A-AC.ML, R046B-FL.ML, R048A-AC.ML, R049A-AC.ML, 
R049B-FL.ML, R050A-AC.ML, R050B-FL.ML, R052A-AC.ML, R100A-FL.ML, 

Rule  43:
R020A-AC.ML, R020B-FL.ML, R020C-FL.ML, R027D-FL.ML, R031A-AC.ML, R031B-FL.ML, 
R036A-AC.ML, R041A-AC.ML, R043A-AC.ML, R043B-FL.ML, 

Rule  44:
R021B-FL.ML, R044A-AC.ML, R044B-FL.ML, 

Rule  45:
R002A-FL.ML, R003A-FL.ML, R011C-FL.ML, R017A-AC.ML, R017J-FL.ML, R017K-FL.ML, 
R018A-AC.ML, R026A-FL.ML, R028A-AC.ML, R028B-AC.ML, R028C-AC.ML, R029A-AC.ML, 
R029D-FL.ML, R030A-AC.ML, R031A-AC.ML, R043B-FL.ML, R045A-AC.ML, R045B-FL.ML, 
R046B-FL.ML, R050A-AC.ML, R050B-FL.ML, R052A-AC.ML, 

Rule  46:
R039A-AC.ML, R046A-AC.ML, R046B-FL.ML, 

Rule  47:
R002A-FL.ML, R003A-FL.ML, R011D-FL.ML, R011E-FL.ML, R016B-AC.ML, R017A-AC.ML, 
R017J-FL.ML, R017K-FL.ML, R028A-AC.ML, R028B-AC.ML, R029A-AC.ML, R029B-AC.ML, 
R031B-FL.ML, R031C-FL.ML, R049A-AC.ML, R049B-FL.ML, R050A-AC.ML, R050B-FL.ML, 
R052A-AC.ML, 

Rule  48:
R002A-FL.ML, R003A-FL.ML, R011A-AC.ML, R011B-FL.ML, R019A-AC.ML, R028A-AC.ML, 
R028B-AC.ML, R029A-AC.ML, R030A-AC.ML, R031A-AC.ML, R032A-AC.ML, R041A-AC.ML, 
R043A-AC.ML, R043B-FL.ML, R048A-AC.ML, R049A-AC.ML, R049B-FL.ML, R050A-AC.ML, 
R050B-FL.ML, 

Rule  49:
R002A-FL.ML, R003A-FL.ML, R011A-AC.ML, R011B-FL.ML, R011C-FL.ML, R014A-AC.ML, 
R018A-AC.ML, R019A-AC.ML, R019B-AC.ML, R019C-FL.ML, R019D-AC.ML, R020A-AC.ML, 
R020B-FL.ML, R020C-FL.ML, R020D-AC.ML, R021A-AC.ML, R021B-FL.ML, R025B-FL.ML, 
R026A-FL.ML, R028A-AC.ML, R028B-AC.ML, R028C-AC.ML, R028D-FL.ML, R029A-AC.ML, 
R029B-AC.ML, R029D-FL.ML, R029E-AC.ML, R030A-AC.ML, R031A-AC.ML, R032A-AC.ML, 
R041A-AC.ML, R043A-AC.ML, R043B-FL.ML, R044A-AC.ML, R044B-FL.ML, R045A-AC.ML, 
R045B-FL.ML, R046B-FL.ML, R048A-AC.ML, R049A-AC.ML, R049B-FL.ML, R050A-AC.ML, 
R050B-FL.ML, R052A-AC.ML, 

Rule  50:
R002A-FL.ML, R003A-FL.ML, R011A-AC.ML, R011E-FL.ML, R017A-AC.ML, R017K-FL.ML, 
R019C-FL.ML, R028B-AC.ML, R050A-AC.ML, R050B-FL.ML, R052A-AC.ML, 

Rule  51:
R011A-AC.ML, R020A-AC.ML, R020B-FL.ML, R020C-FL.ML, R050A-AC.ML, R050B-FL.ML, 

Rule  52:
R002A-FL.ML, R003A-FL.ML, R011A-AC.ML, R011B-FL.ML, R019A-AC.ML, R028A-AC.ML, 
R028B-AC.ML, R029A-AC.ML, R030A-AC.ML, R031A-AC.ML, R032A-AC.ML, R041A-AC.ML, 
R043A-AC.ML, R043B-FL.ML, R048A-AC.ML, R049A-AC.ML, R049B-FL.ML, 


B. Test results from four SML implementations





The test suite was used on the following SML implementations

     Edinburgh Standard ML, Version 4.1.0, December 13, 1991
     using EDML3864 V044

     Micro ML of Umea, Version 0.1, September 24, 1991

     Moscow SML by Sergei Romanenko, Version 0.04b, August 1994

     Moscow SML by Sergei Romanenko, Version 1.00, August 1994

     Standard ML of New Jersey, Version 0.93, February 15, 1993

     Standard ML of New Jersey, Version 0.93, port no. 2 of May
     1994, for OS/2. 

The results of the testing of these SML implementations can be seen
below. The list of programs that were elaborated (and evaluated)
with results different than those expected contains both AC and FL
programs. AC programs appear in the list if they did not elaborate
correctly. FL programs appear in the list if they did indeed
elaborate even though they should not. The same is true for the list
of programs that elaborated differently than expected causing
cryptic error messages. However, the test suite programs listed in
this category elaborated differently than expected causing a cryptic
error message. An example of a cryptic error message is:

Can't unify: int*bool
With:        int*bool*real

In expression: val z = (12,(true,3.3)) : int*bool*real;

Implying that (true,3.3) has type bool.


Edinburgh Standard ML, Version 4.1.0, December 13, 1991

The following programs were elaborated differently than expected:

D005A-AC.ML
D005B-FL.ML
D005C-FL.ML

M001A-AC.ML
R002A-FL.ML
R003A-FL.ML
R011C-FL.ML
R011D-FL.ML
R011E-FL.ML
R017J-FL.ML
R017K-FL.ML
R021b-FL.ML
R031C-FL.ML
R038A-AC.ML
R100A-FL.ML

S002A-FL.ML
S002B-FL.ML
S002C-FL.ML
S002F-FL.ML
Micro ML of Umea, Version 0.1, September 24, 1991

Note that Micro ML of Umea does not support records. All programs
listed below as failing because of the use of records are marked
with an asterisk (*). When compiling the test programs, constructors
were shown in another order than they appeared in the files. An
example of a file, where the order was changed is R029A-AC.ML.

The following programs were elaborated differently than expected:

D001A-AC.ML
D002A-AC.ML
D004A-AC.ML
D005A-AC.ML
D005B-FL.ML
D005C-FL.ML

M001A-AC.ML *M001B-FL.ML *
M003A-FL.ML

R011C-FL.ML
R011D-FL.ML
R011E-FL.ML
R017D-AC.ML
R017G-AC.MLR017H-FL.ML
R017J-FL.ML
R017K-FL.ML
R019C-FL.ML
R020B-FL.ML
R024A-AC.ML
R032A-AC.ML
R034B-AC.MLR038A-AC.ML *

S002F-FL.ML
S002G-FL.ML
The following programs were elaborated differently than expected
causing cryptic error messages:

D006C-FL.ML
D006D-FL.ML
D006E-FL.ML

R002A-FL.ML
R003A-FL.ML
R005A-AC.ML *
R005B-FL.ML *R005C-FL.ML *
R008A-AC.ML *
R010B-FL.ML *
R031B-FL.ML
R031C-FL.ML
R041A-AC.ML *
R043A-AC.ML *
R043B-FL.ML *R044A-AC.ML *
R044B-FL.ML *
R045A-AC.ML *
R045B-FL.ML *
R046A-AC.ML *
R046B-FL.ML *
R048A-AC.ML *
R049A-AC.ML *R049B-FL.ML *
R052A-AC.ML *
R100A-FL.ML

S001B-FL.ML *
S001C-FL.ML *
S001D-FL.ML *

Moscow SML by Sergei Romanenko, Version 0.04b, August 1994

The following programs failed:

R027B-AC.ML

The following programs caused a cryptic error messages:

R005C-FL.ML
R011B-FL.ML


Moscow SML by Sergei Romanenko, Version 1.00, August 1994

The following program caused a cryptic error message:

R011B-FL.ML

Standard ML of New Jersey, Version 0.93, February 15, 1993

The following program was not evaluated correctly:

D001A-AC.ML

In the following declaration

local
  exception A;
  exception B = A;
in
  val test5 = 1 = (case B of A => 1 | B => 2 | _ => 3);
end;

test5 was evaluated to false. The reason is that the compiler did not
match the exception B with the exception A. This does not comply
with rule 139 [page 54]. However, this rule is part of the dynamic
semantics for the Core and it is not tested thoroughly in this test
suite.


Standard ML of New Jersey, Version 0.93, port no. 2 of May 1994,
OS/2

This compiler behaved exactly like the UNIX version of SML of New
Jersey.

