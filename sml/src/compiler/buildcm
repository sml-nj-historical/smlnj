#!/bin/sh
#
# build: build script for CM bootstrapping
#
#   Copyright (c) 1995 by AT&T Bell Laboratories
#
# author: Matthias Blume (blume@cs.princeton.edu)
#
# options:
#   -o image		-- specify the name of the heap image, "sml-cm.ARCH"
#			   is the default.
#   -sml path		-- specify the path to the sml executable, "../bin/sml"
#			   is the default.
#   -yacc path		-- defines the name of the ml-yacc command, "ml-yacc"
#			   is the default.
#   -lex path		-- defines the name of the ml-lex command, "ml-lex"
#			   is the default.
#   -burg path		-- defines the name of the ml-burg command, "ml-burg"
#			   is the default.
#   -rcs path		-- defines the name of the RCS check-out command,
#			   "co -q" is the default
#   -L path-list	-- specify a colon separated search path list for
#			   libraries.
#

tmp=load-all-`hostname`-$$
config=config-`hostname`-$$.sml

trap "rm -f $config $tmp; exit 1" 1 2 3 15

CMD="buildcm"


ROOT="sml-cm"
HEAP_IMAGE=""
SML="./xrun"
# SML="../../bin/sml"

YACC="ml-yacc"
LEX="ml-lex"
BURG="ml-burg"
RCSCO="co -q"
NLL="false"
BIN="../../bin"
CMPATH=""
PROF=""
CHECK=""
STATS=""
CURDIR=`pwd`
cd ../cm/

#
# process command-line options
#
ARGS=""
while [ "$#" != "0" ]
do
    arg=$1
    shift
    case $arg in
	-yacc)
	    if [ "$#" = "0" ]; then
		echo "$CMD: must supply name of ML-Yacc for -yacc option"
		exit 1
	    fi
	    YACC=$1; shift
	;;
	-lex)
	    if [ "$#" = "0" ]; then
		echo "$CMD: must supply name of ML-Lex for -lex option"
		exit 1
	    fi
	    LEX=$1; shift
	;;
	-burg)
	    if [ "$#" = "0" ]; then
		echo "$CMD: must supply name of ML-Burg for -burg option"
		exit 1
	    fi
	    BURG=$1; shift
	;;
	-rcs)
	    if [ "$#" = "0" ]; then
		echo "$CMD: must supply RCS check-out command for -rcs option"
		exit 1
	    fi
	    RCSCO=$1; shift
	;;
	-L)
	    if [ "$#" = "0" ]; then
		echo "$CMD: must supply path spec for -L option"
		exit 1
	    fi
	    CMPATH=$1; shift
	;;
	-nll)
	    NLL="true"
	;;
	-bin)
	    if [ "$#" = "0" ]; then
		echo "$CMD: must supply bin directory path for -bin option"
		exit 1
	    fi
	    BIN=$1; shift
	;;
	-o)
	    if [ "$#" = "0" ]; then
		echo "$CMD: must supply image name for -o option"
		exit 1
	    fi
	    HEAP_IMAGE=$1; shift
	;;
	-sml)
	    if [ "$#" = "0" ]; then
		echo "$CMD: must supply path for -sml option"
		exit 1
	    fi
	    SML=$1; shift
	;;
	-note)
	    if [ "$#" = "0" ]; then
		echo "xmakeml: missing argument for \"-note\" option"
		exit 1
	    fi
	    NOTE="$1\n"; shift
	;;
	-full)
	    ARGS="$ARGS sml-full"
	    NOTE="[-full]\n$NOTE"
	    HEAP_IMAGE="sml-cm-full"
	;;
	-prof)
	    PROF="local open Compiler.Profile in val _ = setMode ACTIVE end;"
	    ;;
	-early-check)
	    CHECK='use "sys/compiler.sig";
                   functor CheckIt (C: COMPILER) = C;
                   structure CheckItOut = CheckIt (Compiler);'
            ;;
	-stats)
	    STATS='Compiler.Stats.summary ();'
	    ;;
	*)
	    ARGS="$ARGS $arg"
	;;
    esac
done

#
# split the pathname and build SML string list
#
if [ "$ARGS" = "" ]; then
    ARGS="sml"
fi

SPACEPATH=`echo $CMPATH | sed -e 's/:/ /g'`
PATHLIST=""
for i in $SPACEPATH
do
	PATHLIST="$PATHLIST \"$i\" :: "
done
PATHLIST="$PATHLIST []"

#
# generate the config.sml file, with the proper yacc and lex paths, etc.
#

cat - > $config <<XXXX
(* config.sml  --- generated by _build_ script *)

structure CmConfig = struct
    val lex = { varname = "CM_LEX", default = "$LEX" }
    val yacc = { varname = "CM_YACC", default = "$YACC" }
    val burg = { varname = "CM_BURG", default = "$BURG" }
    val namelength_limited = $NLL
    val path: string list = $PATHLIST
    val rcsco = { varname = "CM_RCSCO", default = "$RCSCO" }
end
XXXX

sed -e "s|config/config.sml|${config}|" <load-all >$tmp

if [ "$HEAP_IMAGE" = "" ]; then
    HEAP_IMAGE="$ROOT"
fi

cd $CURDIR

$SML $ARGS <<ZZZ
	$PROF
	$CHECK
        val _ = Posix.FileSys.chdir "../cm/";
	use "$tmp";
	$STATS
        Compiler.Stats.summary();
        val _ = Posix.FileSys.chdir "$CURDIR";
	(SMLofNJ.exportML "$HEAP_IMAGE";
         print (Compiler.banner ^
		"\n[built `date`]\n$NOTE[CM&CMB]\n");
         CM.procCmdLine ());
ZZZ

rm -f ../cm/$config ../cm/$tmp
exit 0
