(*
 * This file was automatically generated by MDGen
 * from the machine description file "x86/x86.md".
 *)


functor X86MCEmitter(structure Instr : X86INSTR
                     structure Stream : INSTRUCTION_STREAM
                     structure CodeString : CODE_STRING
                    ) : INSTRUCTION_EMITTER =
struct
   structure I = Instr
   structure S = Stream
   structure C = I.C
   structure Constant = I.Constant
   structure P = S.P
   structure W = Word32
   
   (* X86 is a little endian architecture *)
   
   fun error msg = MLRiscErrorMsg.error("X86MC",msg)
   fun makeStream _ =
   let infix && || << >> ~>>
       val op << = W.<<
       val op >> = W.>>
       val op ~>> = W.~>>
       val op || = W.orb
       val op && = W.andb
       val itow = W.fromInt
       fun emit_bool false = 0w0 : W.word
         | emit_bool true = 0w1 : W.word
       val emit_int = itow
       fun emit_word w = w
       fun emit_label l = itow(Label.addrOf l)
       fun emit_labexp le = itow(LabelExp.valueOf le)
       fun emit_const c = itow(Constant.valueOf c)
       val loc = ref 0
   
       (* emit a byte *)
       fun eByte b =
       let val i = !loc in loc := i + 1; CodeString.update(i,b) end
   
       (* emit the low order byte of a word *)
       (* note: fromLargeWord strips the high order bits! *)
       fun eByteW w =
       let val i = !loc
       in loc := i + 1; CodeString.update(i,Word8.fromLargeWord w) end
   
       fun doNothing _ = ()
   
       fun pseudoOp pOp = P.emitValue{pOp=pOp, loc= !loc,emit=eByte}
   
       fun init n = (CodeString.init n; loc := 0)
   
   
       fun emitter regmap =
       let

   fun emit_CC r = (itow ((regmap r) - 64))
   and emit_FP r = (itow ((regmap r) - 32))
   and emit_GP r = (itow (regmap r))

   fun emitInstr (I.NOP) = (error "NOP")
     | emitInstr (I.JMP(operand, label)) = (error "JMP")
     | emitInstr (I.JCC{cond, opnd}) = (error "JCC")
     | emitInstr (I.CALL(operand, cellset1, cellset2, region)) = (error "CALL")
     | emitInstr (I.RET operand) = (error "RET")
     | emitInstr (I.MOVE{mvOp, src, dst}) = (error "MOVE")
     | emitInstr (I.LEA{r32, addr}) = (error "LEA")
     | emitInstr (I.CMP{lsrc, rsrc}) = (error "CMP")
     | emitInstr (I.BINARY{binOp, src, dst}) = (error "BINARY")
     | emitInstr (I.MULTDIV{multDivOp, src}) = (error "MULTDIV")
     | emitInstr (I.MUL3{dst, src1, src2}) = (error "MUL3")
     | emitInstr (I.UNARY{unOp, opnd}) = (error "UNARY")
     | emitInstr (I.PUSH operand) = (error "PUSH")
     | emitInstr (I.POP operand) = (error "POP")
     | emitInstr (I.CDQ) = (error "CDQ")
     | emitInstr (I.INTO) = (error "INTO")
     | emitInstr (I.COPY{dst, src, tmp}) = (error "COPY")
     | emitInstr (I.FCOPY{dst, src, tmp}) = (error "FCOPY")
     | emitInstr (I.FBINARY{binOp, src, dst}) = (error "FBINARY")
     | emitInstr (I.FUNARY funOp) = (error "FUNARY")
     | emitInstr (I.FUCOMPP) = (error "FUCOMPP")
     | emitInstr (I.FXCH) = (error "FXCH")
     | emitInstr (I.FSTP operand) = (error "FSTP")
     | emitInstr (I.FLD operand) = (error "FLD")
     | emitInstr (I.FILD operand) = (error "FILD")
     | emitInstr (I.FNSTSW) = (error "FNSTSW")
     | emitInstr (I.SAHF) = (error "SAHF")
     | emitInstr (I.ANNOTATION{i, a}) = (error "ANNOTATION")
     | emitInstr (I.GROUP annotation) = (error "GROUP")
       in
           emitInstr
       end
   
   in  S.STREAM{beginCluster=init,
                pseudoOp=pseudoOp,
                emit=emitter,
                endCluster=doNothing,
                defineLabel=doNothing,
                entryLabel=doNothing,
                comment=doNothing,
                exitBlock=doNothing,
                annotation=doNothing,
                phi=doNothing,
                alias=doNothing
               }
   end
end

