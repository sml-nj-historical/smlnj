(*
 * This file was automatically generated by MDGen (v2.0)
 * from the machine description file "x86/x86.md".
 *)


functor X86MCEmitter(structure Instr : X86INSTR
                     structure Stream : INSTRUCTION_STREAM
                     structure CodeString : CODE_STRING
                    ) : INSTRUCTION_EMITTER =
struct
   structure I = Instr
   structure S = Stream
   structure C = I.C
   structure Constant = I.Constant
   structure LabelExp = I.LabelExp
   structure P = S.P
   structure W = Word32
   
   (* X86 is little endian *)
   
   fun error msg = MLRiscErrorMsg.error("X86MC",msg)
   fun makeStream _ =
   let infix && || << >> ~>>
       val op << = W.<<
       val op >> = W.>>
       val op ~>> = W.~>>
       val op || = W.orb
       val op && = W.andb
       val itow = W.fromInt
       fun emit_bool false = 0w0 : W.word
         | emit_bool true = 0w1 : W.word
       val emit_int = itow
       fun emit_word w = w
       fun emit_label l = itow(Label.addrOf l)
       fun emit_labexp le = itow(LabelExp.valueOf le)
       fun emit_const c = itow(Constant.valueOf c)
       val loc = ref 0
   
       (* emit a byte *)
       fun eByte b =
       let val i = !loc in loc := i + 1; CodeString.update(i,b) end
   
       (* emit the low order byte of a word *)
       (* note: fromLargeWord strips the high order bits! *)
       fun eByteW w =
       let val i = !loc
       in loc := i + 1; CodeString.update(i,Word8.fromLargeWord w) end
   
       fun doNothing _ = ()
   
       fun pseudoOp pOp = P.emitValue{pOp=pOp, loc= !loc,emit=eByte}
   
       fun init n = (CodeString.init n; loc := 0)
   
   
       fun emitter regmap =
       let
   fun emit_GP r = itow (regmap r)
   and emit_FP r = itow ((regmap r) - 32)
   and emit_CC r = itow ((regmap r) - 64)
   and emit_MEM r = itow ((regmap r) - 64)
   and emit_CTRL r = itow ((regmap r) - 64)
   fun emitInstr (I.NOP) = error "NOP"
     | emitInstr (I.JMP(operand, label)) = error "JMP"
     | emitInstr (I.JCC{cond, opnd}) = error "JCC"
     | emitInstr (I.CALL(operand, cellset1, cellset2, region)) = error "CALL"
     | emitInstr (I.LEAVE) = error "LEAVE"
     | emitInstr (I.RET operand) = error "RET"
     | emitInstr (I.MOVE{mvOp, src, dst}) = error "MOVE"
     | emitInstr (I.LEA{r32, addr}) = error "LEA"
     | emitInstr (I.CMPL{lsrc, rsrc}) = error "CMPL"
     | emitInstr (I.CMPW{lsrc, rsrc}) = error "CMPW"
     | emitInstr (I.CMPB{lsrc, rsrc}) = error "CMPB"
     | emitInstr (I.TESTL{lsrc, rsrc}) = error "TESTL"
     | emitInstr (I.TESTW{lsrc, rsrc}) = error "TESTW"
     | emitInstr (I.TESTB{lsrc, rsrc}) = error "TESTB"
     | emitInstr (I.BINARY{binOp, src, dst}) = error "BINARY"
     | emitInstr (I.MULTDIV{multDivOp, src}) = error "MULTDIV"
     | emitInstr (I.MUL3{dst, src2, src1}) = error "MUL3"
     | emitInstr (I.UNARY{unOp, opnd}) = error "UNARY"
     | emitInstr (I.SET{cond, opnd}) = error "SET"
     | emitInstr (I.CMOV{cond, src, dst}) = error "CMOV"
     | emitInstr (I.PUSHL operand) = error "PUSHL"
     | emitInstr (I.PUSHW operand) = error "PUSHW"
     | emitInstr (I.PUSHB operand) = error "PUSHB"
     | emitInstr (I.POP operand) = error "POP"
     | emitInstr (I.CDQ) = error "CDQ"
     | emitInstr (I.INTO) = error "INTO"
     | emitInstr (I.COPY{dst, src, tmp}) = error "COPY"
     | emitInstr (I.FCOPY{dst, src, tmp}) = error "FCOPY"
     | emitInstr (I.FBINARY{binOp, src, dst}) = error "FBINARY"
     | emitInstr (I.FUNARY funOp) = error "FUNARY"
     | emitInstr (I.FUCOMPP) = error "FUCOMPP"
     | emitInstr (I.FCOM) = error "FCOM"
     | emitInstr (I.FCOMPP) = error "FCOMPP"
     | emitInstr (I.FXCH{opnd}) = error "FXCH"
     | emitInstr (I.FSTPL operand) = error "FSTPL"
     | emitInstr (I.FSTPS operand) = error "FSTPS"
     | emitInstr (I.FLDL operand) = error "FLDL"
     | emitInstr (I.FLDS operand) = error "FLDS"
     | emitInstr (I.FILD operand) = error "FILD"
     | emitInstr (I.FNSTSW) = error "FNSTSW"
     | emitInstr (I.FENV{fenvOp, opnd}) = error "FENV"
     | emitInstr (I.SAHF) = error "SAHF"
     | emitInstr (I.ANNOTATION{i, a}) = error "ANNOTATION"
       in
           emitInstr
       end
   
   in  S.STREAM{beginCluster=init,
                pseudoOp=pseudoOp,
                emit=emitter,
                endCluster=doNothing,
                defineLabel=doNothing,
                entryLabel=doNothing,
                comment=doNothing,
                exitBlock=doNothing,
                annotation=doNothing,
                phi=doNothing,
                alias=doNothing
               }
   end
end

