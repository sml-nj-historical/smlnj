(*
 * Basic Instruction properties that must be supported on all architectures.
 *
 * -- Allen
 *)
signature INSN_PROPERTIES = 
sig
   structure C : CELLS
   structure I : INSTRUCTIONS

   sharing I.C = C 

      (* classify instructions *)
   datatype kind = IK_JUMP   (* branches, including returns *)
                 | IK_NOP    (* no ops *)
                 | IK_INSTR  (* normal instructions *)
                 | IK_COPY   (* parallel copy *)
                 | IK_CALL   (* call instructions *)
                 | IK_GROUP  (* A nested region of instructions.
                              * These are generated by various optimization
                              * phases.
                              *)
                 | IK_PHI    (* A phi node (SSA) *)
                 | IK_SINK   (* A source node (SSA) *)
                 | IK_SOURCE (* A sink node (SSA) *)

   val instrKind  : I.instruction -> kind

      (* parallel moves *) 
   val moveInstr  : I.instruction -> bool
   val moveTmpR   : I.instruction -> C.cell option
   val moveDstSrc : I.instruction -> C.cell list * C.cell list

      (* no op *)
   val nop 	  : unit -> I.instruction

      (* jump instruction *)
   val jump       : Label.label -> I.instruction

      (* load immediate; must be within immedRange *)
   val immedRange : {lo:int, hi:int}
   val loadImmed  : {immed:int, t:C.cell} -> I.instruction

     (* 
      * Targets of a branch instruction 
      * precondition: instruction must be of type IK_JUMP.
      *)
   datatype target = LABELLED of Label.label | FALLTHROUGH | ESCAPES
   val branchTargets : I.instruction -> target list

      (* Set the branch target; no effect if not a branch instruction *)
   val setTargets : I.instruction * Label.label list -> I.instruction
 
      (* equality and hashing on operands *)
   val eqOpn      : I.operand * I.operand -> bool
   val hashOpn    : I.operand -> word

      (* Negate the branching condition; raises NegateConditional
       * if it is impossible to negate
       *)
   exception NegateConditional
   val negateConditional : I.instruction -> I.instruction

     (* definition/use for the RA *)
   val defUse     : C.cellkind -> 
                      I.instruction -> (C.cell list * C.cell list)

     (* annotations *)
   val getAnnotations : I.instruction ->
                           I.instruction * Annotations.annotation list
   val annotate       : I.instruction * Annotations.annotation -> I.instruction

     (*
      * Nested regions.
      * These functions allow the client to convert a complex region
      * of instructions (wrapped around by an annotation) into an instruction
      * and vice versa.
      *)
   val getGroup  : I.instruction -> Annotations.annotation
   val makeGroup : Annotations.annotation -> I.instruction
end

